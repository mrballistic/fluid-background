<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Working Fluid</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
    }
    
    canvas {
      display: block;
      cursor: crosshair;
    }
    
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 350px;
      font-size: 14px;
    }
    
    .status {
      margin: 5px 0;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .success { background: rgba(0, 255, 0, 0.2); color: #0f0; }
    .info { background: rgba(0, 0, 255, 0.2); color: #88f; }
    
    .fps {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="overlay">
    <h3 style="margin: 0 0 10px 0;">Simple Working Fluid</h3>
    <div id="status"></div>
    <div style="margin-top: 10px; font-size: 11px; color: #aaa;">
      Move your mouse to create fluid effects!<br>
      This version prioritizes working over complexity.
    </div>
  </div>
  <div class="fps" id="fps">FPS: --</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const fpsDiv = document.getElementById('fps');
    
    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;
    
    function addStatus(message, type = 'info') {
      const div = document.createElement('div');
      div.className = `status ${type}`;
      div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
      statusDiv.appendChild(div);
      
      while (statusDiv.children.length > 6) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
    }
    
    // Set canvas size
    function resizeCanvas() {
      canvas.width = Math.floor(window.innerWidth * 0.8);
      canvas.height = Math.floor(window.innerHeight * 0.8);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Simplified but effective fluid simulation
    class SimpleFluidSimulation {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.size = width * height;
        
        // Simplified state - just what we need
        this.density = new Float32Array(this.size);
        this.velocityX = new Float32Array(this.size);
        this.velocityY = new Float32Array(this.size);
        this.prevDensity = new Float32Array(this.size);
        this.prevVelocityX = new Float32Array(this.size);
        this.prevVelocityY = new Float32Array(this.size);
        
        addStatus(`Simple fluid: ${width}x${height}`, 'success');
      }
      
      IX(x, y) {
        return Math.max(0, Math.min(this.size - 1, y * this.width + x));
      }
      
      addDensity(x, y, amount) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        this.density[this.IX(x, y)] += amount;
      }
      
      addVelocity(x, y, vx, vy) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        const index = this.IX(x, y);
        this.velocityX[index] += vx;
        this.velocityY[index] += vy;
      }
      
      // Very simplified fluid step - focus on working, not perfect physics
      step() {
        // Simple diffusion
        for (let i = 0; i < this.size; i++) {
          this.prevDensity[i] = this.density[i];
          this.prevVelocityX[i] = this.velocityX[i];
          this.prevVelocityY[i] = this.velocityY[i];
        }
        
        // Simple advection and diffusion
        for (let y = 1; y < this.height - 1; y++) {
          for (let x = 1; x < this.width - 1; x++) {
            const index = this.IX(x, y);
            
            // Get velocity at this point
            const vx = this.prevVelocityX[index] * 0.1;
            const vy = this.prevVelocityY[index] * 0.1;
            
            // Simple advection - move density based on velocity
            const sourceX = Math.max(0, Math.min(this.width - 1, x - vx));
            const sourceY = Math.max(0, Math.min(this.height - 1, y - vy));
            
            const x0 = Math.floor(sourceX);
            const y0 = Math.floor(sourceY);
            const x1 = Math.min(this.width - 1, x0 + 1);
            const y1 = Math.min(this.height - 1, y0 + 1);
            
            const fx = sourceX - x0;
            const fy = sourceY - y0;
            
            // Bilinear interpolation
            const density00 = this.prevDensity[this.IX(x0, y0)];
            const density10 = this.prevDensity[this.IX(x1, y0)];
            const density01 = this.prevDensity[this.IX(x0, y1)];
            const density11 = this.prevDensity[this.IX(x1, y1)];
            
            this.density[index] = 
              density00 * (1 - fx) * (1 - fy) +
              density10 * fx * (1 - fy) +
              density01 * (1 - fx) * fy +
              density11 * fx * fy;
            
            // Simple velocity diffusion
            const neighbors = [
              this.IX(x-1, y), this.IX(x+1, y),
              this.IX(x, y-1), this.IX(x, y+1)
            ];
            
            let avgVelX = this.prevVelocityX[index];
            let avgVelY = this.prevVelocityY[index];
            
            neighbors.forEach(nIndex => {
              if (nIndex >= 0 && nIndex < this.size) {
                avgVelX += this.prevVelocityX[nIndex] * 0.05;
                avgVelY += this.prevVelocityY[nIndex] * 0.05;
              }
            });
            
            this.velocityX[index] = avgVelX * 0.99; // Damping
            this.velocityY[index] = avgVelY * 0.99;
          }
        }
        
        // Fade density
        for (let i = 0; i < this.size; i++) {
          this.density[i] *= 0.995;
          if (this.density[i] < 0.1) {
            this.density[i] = 0;
          }
        }
      }
    }
    
    // Initialize fluid with reasonable resolution
    const fluidWidth = Math.floor(canvas.width / 4);
    const fluidHeight = Math.floor(canvas.height / 4);
    const fluid = new SimpleFluidSimulation(fluidWidth, fluidHeight);
    
    // Mouse tracking
    let mouse = { x: 0, y: 0, lastX: 0, lastY: 0, down: false };
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.lastX = mouse.x;
      mouse.lastY = mouse.y;
      mouse.x = (e.clientX - rect.left) / rect.width;
      mouse.y = (e.clientY - rect.top) / rect.height;
    });
    
    canvas.addEventListener('mousedown', () => {
      mouse.down = true;
      addStatus('Creating fluid effects!', 'info');
    });
    
    canvas.addEventListener('mouseup', () => {
      mouse.down = false;
    });
    
    // Animation loop
    function animate(currentTime) {
      // Calculate FPS
      frameCount++;
      if (currentTime - lastTime >= 1000) {
        fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        fpsDiv.textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastTime = currentTime;
      }
      
      // Add mouse influence
      if (mouse.x > 0 && mouse.y > 0) {
        const fluidX = Math.floor(mouse.x * fluidWidth);
        const fluidY = Math.floor(mouse.y * fluidHeight);
        
        const dx = (mouse.x - mouse.lastX) * fluidWidth;
        const dy = (mouse.y - mouse.lastY) * fluidHeight;
        
        if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1 || mouse.down) {
          const radius = mouse.down ? 3 : 2;
          const densityAmount = mouse.down ? 80 : 40;
          const velocityScale = mouse.down ? 30 : 15;
          
          for (let dy_offset = -radius; dy_offset <= radius; dy_offset++) {
            for (let dx_offset = -radius; dx_offset <= radius; dx_offset++) {
              const distance = Math.sqrt(dx_offset * dx_offset + dy_offset * dy_offset);
              if (distance <= radius) {
                const factor = (1 - distance / radius);
                fluid.addDensity(fluidX + dx_offset, fluidY + dy_offset, densityAmount * factor);
                fluid.addVelocity(fluidX + dx_offset, fluidY + dy_offset, 
                  dx * velocityScale * factor, 
                  dy * velocityScale * factor);
              }
            }
          }
        }
      }
      
      // Update fluid simulation
      fluid.step();
      
      // Clear canvas with slight fade
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Render fluid
      const imageData = ctx.createImageData(fluidWidth, fluidHeight);
      const data = imageData.data;
      
      for (let i = 0; i < fluid.size; i++) {
        const density = Math.min(1, fluid.density[i] / 80);
        
        if (density > 0.05) {
          // Create colors based on velocity
          const vx = fluid.velocityX[i];
          const vy = fluid.velocityY[i];
          const velocity = Math.sqrt(vx * vx + vy * vy);
          
          const hue = (Math.atan2(vy, vx) * 180 / Math.PI + 180 + currentTime * 0.05) % 360;
          const saturation = Math.min(100, velocity * 5 + 50);
          const lightness = Math.min(80, density * 100 + 20);
          
          // Convert HSL to RGB
          const c = (1 - Math.abs(2 * lightness/100 - 1)) * saturation/100;
          const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
          const m = lightness/100 - c / 2;
          
          let r, g, b;
          if (hue < 60) { r = c; g = x; b = 0; }
          else if (hue < 120) { r = x; g = c; b = 0; }
          else if (hue < 180) { r = 0; g = c; b = x; }
          else if (hue < 240) { r = 0; g = x; b = c; }
          else if (hue < 300) { r = x; g = 0; b = c; }
          else { r = c; g = 0; b = x; }
          
          data[i * 4] = Math.floor((r + m) * 255);
          data[i * 4 + 1] = Math.floor((g + m) * 255);
          data[i * 4 + 2] = Math.floor((b + m) * 255);
          data[i * 4 + 3] = Math.floor(density * 255);
        } else {
          data[i * 4] = 0;
          data[i * 4 + 1] = 0;
          data[i * 4 + 2] = 0;
          data[i * 4 + 3] = 0;
        }
      }
      
      // Draw to canvas
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = fluidWidth;
      tempCanvas.height = fluidHeight;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(imageData, 0, 0);
      
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.globalCompositeOperation = 'lighter';
      ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
      
      requestAnimationFrame(animate);
    }
    
    // Start
    addStatus('âœ… Simple fluid simulation ready!', 'success');
    addStatus('Move your mouse to create effects', 'info');
    requestAnimationFrame(animate);
  </script>
</body>
</html>