<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Direct Hooks Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
    }
    
    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 400px;
    }
    
    .status {
      margin: 5px 0;
      padding: 5px;
      border-radius: 3px;
      font-size: 13px;
    }
    
    .success { background: rgba(0, 255, 0, 0.2); }
    .error { background: rgba(255, 0, 0, 0.2); }
    .info { background: rgba(0, 0, 255, 0.2); }
    .warning { background: rgba(255, 255, 0, 0.2); }
  </style>
</head>
<body>
  <div class="container">
    <div id="root"></div>
    <div class="overlay">
      <h3>Direct Hooks Test</h3>
      <div id="status"></div>
    </div>
  </div>

  <!-- React from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <script type="module">
    const { useState, useEffect, useRef, useCallback } = React;
    const { createRoot } = ReactDOM;

    // Status logging
    function addStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      const div = document.createElement('div');
      div.className = `status ${type}`;
      div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
      statusDiv.appendChild(div);
      console.log(`[${type.toUpperCase()}] ${message}`);
      
      // Keep only last 10 messages
      while (statusDiv.children.length > 10) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
    }

    // Simplified fluid simulation hook that mimics our real implementation
    function useTestFluidSimulation() {
      const canvasRef = useRef(null);
      const [isInitialized, setIsInitialized] = useState(false);
      const [error, setError] = useState(null);
      const glRef = useRef(null);
      const animationRef = useRef(null);
      const framebuffersRef = useRef([]);

      const initializeWebGL = useCallback(async () => {
        const canvas = canvasRef.current;
        if (!canvas) {
          addStatus('Canvas not available', 'error');
          return false;
        }

        try {
          // Set canvas size
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.max(1, Math.floor(rect.width * dpr));
          canvas.height = Math.max(1, Math.floor(rect.height * dpr));
          
          addStatus(`Canvas size: ${canvas.width}x${canvas.height}`, 'info');

          // Create WebGL context with the same settings as our real implementation
          const gl = canvas.getContext('webgl2', {
            alpha: false,
            depth: false,
            stencil: false,
            antialias: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'default',
            failIfMajorPerformanceCaveat: false,
          }) || canvas.getContext('webgl', {
            alpha: false,
            depth: false,
            stencil: false,
            antialias: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'default',
            failIfMajorPerformanceCaveat: false,
          });

          if (!gl) {
            throw new Error('WebGL not supported');
          }

          if (gl.isContextLost()) {
            throw new Error('WebGL context lost immediately');
          }

          glRef.current = gl;
          addStatus('WebGL context created', 'success');

          // Test creating multiple framebuffers like our simulation does
          const framebuffers = [];
          const textures = [];
          
          // Create framebuffers for velocity, density, pressure (like our real simulation)
          const fbNames = ['velocity', 'density', 'pressure', 'divergence', 'curl'];
          
          for (let i = 0; i < fbNames.length; i++) {
            const framebuffer = gl.createFramebuffer();
            const texture = gl.createTexture();

            if (!framebuffer || !texture) {
              throw new Error(`Failed to create ${fbNames[i]} framebuffer resources`);
            }

            // Use smaller dimensions for testing
            const width = Math.min(512, canvas.width);
            const height = Math.min(512, canvas.height);

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (status !== gl.FRAMEBUFFER_COMPLETE) {
              throw new Error(`${fbNames[i]} framebuffer incomplete: ${status}`);
            }

            // Clear the framebuffer
            gl.viewport(0, 0, width, height);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            framebuffers.push({ name: fbNames[i], framebuffer, texture, width, height });
            addStatus(`✅ Created ${fbNames[i]} framebuffer (${width}x${height})`, 'success');
          }

          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          framebuffersRef.current = framebuffers;

          // Set up basic rendering state
          gl.viewport(0, 0, canvas.width, canvas.height);
          gl.clearColor(0.1, 0.1, 0.2, 1.0);
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.STENCIL_TEST);
          gl.disable(gl.CULL_FACE);

          setIsInitialized(true);
          addStatus('✅ All framebuffers created successfully!', 'success');
          return true;

        } catch (err) {
          const errorMsg = err.message || 'Unknown error';
          addStatus(`❌ Initialization failed: ${errorMsg}`, 'error');
          setError(errorMsg);
          return false;
        }
      }, []);

      const animate = useCallback(() => {
        const gl = glRef.current;
        if (!gl || gl.isContextLost()) {
          addStatus('Animation stopped: context lost', 'error');
          return;
        }

        // Simple animation - cycle through framebuffers and clear with different colors
        const time = Date.now() * 0.001;
        const framebuffers = framebuffersRef.current;
        
        if (framebuffers.length > 0) {
          const fbIndex = Math.floor(time * 0.5) % framebuffers.length;
          const fb = framebuffers[fbIndex];
          
          gl.bindFramebuffer(gl.FRAMEBUFFER, fb.framebuffer);
          gl.viewport(0, 0, fb.width, fb.height);
          
          const r = Math.sin(time * 0.5) * 0.5 + 0.5;
          const g = Math.sin(time * 0.7) * 0.5 + 0.5;
          const b = Math.sin(time * 0.9) * 0.5 + 0.5;
          
          gl.clearColor(r * 0.3, g * 0.3, b * 0.3, 1.0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }

        // Render to main canvas
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        
        const r = Math.sin(time * 0.3) * 0.5 + 0.5;
        const g = Math.sin(time * 0.5) * 0.5 + 0.5;
        const b = Math.sin(time * 0.7) * 0.5 + 0.5;
        
        gl.clearColor(r * 0.1, g * 0.1, b * 0.1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        animationRef.current = requestAnimationFrame(animate);
      }, []);

      useEffect(() => {
        initializeWebGL().then(success => {
          if (success) {
            animate();
          }
        });

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
          
          // Cleanup framebuffers
          const gl = glRef.current;
          if (gl && framebuffersRef.current) {
            framebuffersRef.current.forEach(fb => {
              gl.deleteFramebuffer(fb.framebuffer);
              gl.deleteTexture(fb.texture);
            });
          }
        };
      }, [initializeWebGL, animate]);

      return { canvasRef, isInitialized, error };
    }

    // Test component
    function FluidTest() {
      const { canvasRef, isInitialized, error } = useTestFluidSimulation();

      return React.createElement('canvas', {
        ref: canvasRef,
        style: {
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%'
        }
      });
    }

    // Render
    const root = createRoot(document.getElementById('root'));
    root.render(React.createElement(FluidTest));

    addStatus('Direct hooks test started', 'info');
  </script>
</body>
</html>