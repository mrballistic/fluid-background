<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SplashCursor Vanilla JS - Advanced Usage</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .slider-container input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .slider-value {
            font-size: 12px;
            color: #ccc;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            margin: 2px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button.secondary {
            background: #2196F3;
        }
        
        button.secondary:hover {
            background: #1976D2;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .stat-label {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin: 20px 0;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-error { color: #f44336; }
        .log-warning { color: #ff9800; }
        .log-info { color: #2196f3; }
        .log-success { color: #4caf50; }
    </style>
</head>
<body>
    <div class="container">
        <h1>SplashCursor Advanced Demo</h1>
        <p>Comprehensive demonstration of all SplashCursor vanilla JS features</p>
        
        <div class="controls-grid">
            <div class="control-group">
                <h3>Basic Controls</h3>
                <button id="startBtn">Start</button>
                <button id="stopBtn" class="secondary">Stop</button>
                <button id="resetBtn" class="secondary">Reset</button>
                <button id="destroyBtn" style="background: #f44336;">Destroy</button>
            </div>
            
            <div class="control-group">
                <h3>Visual Settings</h3>
                <div class="slider-container">
                    <label>Intensity</label>
                    <input type="range" id="intensitySlider" min="0" max="1" step="0.1" value="0.8">
                    <div class="slider-value" id="intensityValue">0.8</div>
                </div>
                <div class="slider-container">
                    <label>Particle Count</label>
                    <input type="range" id="particleCountSlider" min="10" max="300" step="10" value="150">
                    <div class="slider-value" id="particleCountValue">150</div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Physics Settings</h3>
                <div class="slider-container">
                    <label>Gravity</label>
                    <input type="range" id="gravitySlider" min="-0.1" max="0.1" step="0.01" value="0.01">
                    <div class="slider-value" id="gravityValue">0.01</div>
                </div>
                <div class="slider-container">
                    <label>Drag</label>
                    <input type="range" id="dragSlider" min="0.9" max="1" step="0.001" value="0.997">
                    <div class="slider-value" id="dragValue">0.997</div>
                </div>
                <button id="bounceToggle">Bounce: ON</button>
            </div>
            
            <div class="control-group">
                <h3>Color Modes</h3>
                <button id="rainbowMode">Rainbow</button>
                <button id="singleMode" class="secondary">Single</button>
                <button id="gradientMode" class="secondary">Gradient</button>
                <button id="velocityMode" class="secondary">Velocity</button>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="fpsDisplay">0</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="particleDisplay">0</div>
                <div class="stat-label">Particles</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="qualityDisplay">high</div>
                <div class="stat-label">Quality</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statusDisplay">stopped</div>
                <div class="stat-label">Status</div>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Event Log</h3>
            <div class="log" id="eventLog"></div>
            <button id="clearLogBtn" class="secondary">Clear Log</button>
        </div>
    </div>

    <script type="module">
        // Enhanced mock implementation for advanced demo
        class AdvancedMockSplashCursor {
            constructor(options = {}) {
                this.options = {
                    intensity: 0.8,
                    particleCount: 150,
                    gravity: 0.01,
                    drag: 0.997,
                    bounceEnabled: true,
                    colors: { mode: 'rainbow' },
                    ...options
                };
                
                this.active = false;
                this.fps = 0;
                this.particles = 0;
                this.quality = 'high';
                this.canvas = null;
                this.animationId = null;
                this.trails = [];
                this.mousePos = { x: 0, y: 0 };
                this.lastMousePos = { x: 0, y: 0 };
                
                this.performanceCallbacks = [];
                this.qualityCallbacks = [];
                this.errorCallbacks = [];
                
                this.setupCanvas();
                this.setupEvents();
                this.log('SplashCursor initialized', 'success');
            }
            
            setupCanvas() {
                this.canvas = document.createElement('canvas');
                this.canvas.style.position = 'fixed';
                this.canvas.style.top = '0';
                this.canvas.style.left = '0';
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.pointerEvents = 'none';
                this.canvas.style.zIndex = '9999';
                document.body.appendChild(this.canvas);
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            setupEvents() {
                document.addEventListener('mousemove', (e) => {
                    this.lastMousePos = { ...this.mousePos };
                    this.mousePos.x = e.clientX;
                    this.mousePos.y = e.clientY;
                    
                    if (this.active) {
                        const velocity = {
                            x: this.mousePos.x - this.lastMousePos.x,
                            y: this.mousePos.y - this.lastMousePos.y
                        };
                        
                        const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
                        
                        if (speed > 1) {
                            this.addTrail(e.clientX, e.clientY, speed);
                        }
                    }
                });
            }
            
            addTrail(x, y, speed) {
                const intensity = Math.min(speed / 20, 1) * this.options.intensity;
                
                for (let i = 0; i < Math.ceil(intensity * 3); i++) {
                    this.trails.push({
                        x: x + (Math.random() - 0.5) * 10,
                        y: y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 1.0,
                        maxLife: 1.0 + Math.random(),
                        size: 5 + Math.random() * 15,
                        hue: this.getTrailColor(speed)
                    });
                }
                
                while (this.trails.length > this.options.particleCount) {
                    this.trails.shift();
                }
            }
            
            getTrailColor(speed) {
                switch (this.options.colors.mode) {
                    case 'rainbow':
                        return (Date.now() / 10) % 360;
                    case 'velocity':
                        return (speed * 10) % 360;
                    case 'single':
                        return this.options.colors.baseHue || 200;
                    case 'gradient':
                        return ((Date.now() / 50) % 120) + (this.options.colors.baseHue || 200);
                    default:
                        return 200;
                }
            }
            
            animate = () => {
                if (!this.active) return;
                
                const ctx = this.canvas.getContext('2d');
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Update trails
                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const trail = this.trails[i];
                    
                    // Apply physics
                    trail.vy += this.options.gravity * 100;
                    trail.vx *= this.options.drag;
                    trail.vy *= this.options.drag;
                    
                    trail.x += trail.vx;
                    trail.y += trail.vy;
                    
                    // Bounce off edges
                    if (this.options.bounceEnabled) {
                        if (trail.x < 0 || trail.x > this.canvas.width) {
                            trail.vx *= -0.8;
                            trail.x = Math.max(0, Math.min(this.canvas.width, trail.x));
                        }
                        if (trail.y < 0 || trail.y > this.canvas.height) {
                            trail.vy *= -0.8;
                            trail.y = Math.max(0, Math.min(this.canvas.height, trail.y));
                        }
                    }
                    
                    trail.life -= 0.02;
                    
                    if (trail.life <= 0) {
                        this.trails.splice(i, 1);
                        continue;
                    }
                    
                    // Draw trail
                    const alpha = trail.life / trail.maxLife;
                    const size = trail.size * alpha;
                    
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${trail.hue}, 80%, 60%, ${alpha * 0.4})`;
                    ctx.fill();
                }
                
                this.particles = this.trails.length;
                this.fps = 60; // Mock FPS
                
                // Simulate performance monitoring
                if (Math.random() < 0.01) { // 1% chance per frame
                    this.performanceCallbacks.forEach(cb => {
                        cb({
                            fps: this.fps,
                            frameTime: 16.67,
                            averageFps: this.fps,
                            particleCount: this.particles
                        });
                    });
                }
                
                this.animationId = requestAnimationFrame(this.animate);
            };
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                
                const logElement = document.getElementById('eventLog');
                if (logElement) {
                    const entry = document.createElement('div');
                    entry.className = `log-entry log-${type}`;
                    entry.textContent = logEntry;
                    logElement.appendChild(entry);
                    logElement.scrollTop = logElement.scrollHeight;
                }
                
                console.log(logEntry);
            }
            
            // Public API
            start() {
                if (this.active) return;
                this.active = true;
                this.animate();
                this.log('SplashCursor started', 'success');
            }
            
            stop() {
                if (!this.active) return;
                this.active = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                this.log('SplashCursor stopped', 'info');
            }
            
            reset() {
                this.trails = [];
                this.particles = 0;
                this.log('SplashCursor reset', 'info');
            }
            
            destroy() {
                this.stop();
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                this.log('SplashCursor destroyed', 'warning');
            }
            
            updateConfig(config) {
                const oldConfig = { ...this.options };
                Object.assign(this.options, config);
                
                if (config.particleCount !== undefined) {
                    while (this.trails.length > config.particleCount) {
                        this.trails.shift();
                    }
                }
                
                this.log(`Config updated: ${JSON.stringify(config)}`, 'info');
            }
            
            getFPS() { return this.fps; }
            getParticleCount() { return this.particles; }
            getQuality() { return this.quality; }
            isActive() { return this.active; }
            
            onPerformanceUpdate(callback) {
                this.performanceCallbacks.push(callback);
                return () => {
                    const index = this.performanceCallbacks.indexOf(callback);
                    if (index > -1) this.performanceCallbacks.splice(index, 1);
                };
            }
            
            onQualityChange(callback) {
                this.qualityCallbacks.push(callback);
                return () => {
                    const index = this.qualityCallbacks.indexOf(callback);
                    if (index > -1) this.qualityCallbacks.splice(index, 1);
                };
            }
            
            onError(callback) {
                this.errorCallbacks.push(callback);
                return () => {
                    const index = this.errorCallbacks.indexOf(callback);
                    if (index > -1) this.errorCallbacks.splice(index, 1);
                };
            }
        }
        
        // Create splash cursor instance
        const splashCursor = new AdvancedMockSplashCursor();
        
        // Set up event listeners
        splashCursor.onPerformanceUpdate((metrics) => {
            splashCursor.log(`Performance: ${metrics.fps.toFixed(1)} FPS, ${metrics.particleCount} particles`, 'info');
        });
        
        splashCursor.onError((error, context) => {
            splashCursor.log(`Error in ${context}: ${error.message}`, 'error');
        });
        
        // Control event listeners
        document.getElementById('startBtn').addEventListener('click', () => splashCursor.start());
        document.getElementById('stopBtn').addEventListener('click', () => splashCursor.stop());
        document.getElementById('resetBtn').addEventListener('click', () => splashCursor.reset());
        document.getElementById('destroyBtn').addEventListener('click', () => splashCursor.destroy());
        
        // Slider controls
        function setupSlider(id, property, callback) {
            const slider = document.getElementById(id + 'Slider');
            const display = document.getElementById(id + 'Value');
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                display.textContent = value;
                
                const config = {};
                config[property] = value;
                splashCursor.updateConfig(config);
                
                if (callback) callback(value);
            });
        }
        
        setupSlider('intensity', 'intensity');
        setupSlider('particleCount', 'particleCount');
        setupSlider('gravity', 'gravity');
        setupSlider('drag', 'drag');
        
        // Color mode buttons
        document.getElementById('rainbowMode').addEventListener('click', () => {
            splashCursor.updateConfig({ colors: { mode: 'rainbow' } });
        });
        
        document.getElementById('singleMode').addEventListener('click', () => {
            splashCursor.updateConfig({ colors: { mode: 'single', baseHue: 200 } });
        });
        
        document.getElementById('gradientMode').addEventListener('click', () => {
            splashCursor.updateConfig({ colors: { mode: 'gradient', baseHue: 280 } });
        });
        
        document.getElementById('velocityMode').addEventListener('click', () => {
            splashCursor.updateConfig({ colors: { mode: 'velocity' } });
        });
        
        // Bounce toggle
        let bounceEnabled = true;
        document.getElementById('bounceToggle').addEventListener('click', (e) => {
            bounceEnabled = !bounceEnabled;
            e.target.textContent = `Bounce: ${bounceEnabled ? 'ON' : 'OFF'}`;
            splashCursor.updateConfig({ bounceEnabled });
        });
        
        // Clear log
        document.getElementById('clearLogBtn').addEventListener('click', () => {
            document.getElementById('eventLog').innerHTML = '';
        });
        
        // Update stats display
        function updateStats() {
            document.getElementById('fpsDisplay').textContent = splashCursor.getFPS();
            document.getElementById('particleDisplay').textContent = splashCursor.getParticleCount();
            document.getElementById('qualityDisplay').textContent = splashCursor.getQuality();
            document.getElementById('statusDisplay').textContent = splashCursor.isActive() ? 'running' : 'stopped';
        }
        
        setInterval(updateStats, 100);
        
        // Auto-start
        splashCursor.start();
    </script>
</body>
</html>