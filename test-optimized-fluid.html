<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Optimized Fluid Dynamics</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
    }
    
    canvas {
      display: block;
      cursor: crosshair;
    }
    
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 350px;
      font-size: 14px;
    }
    
    .status {
      margin: 5px 0;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .success { background: rgba(0, 255, 0, 0.2); color: #0f0; }
    .info { background: rgba(0, 0, 255, 0.2); color: #88f; }
    
    .fps {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="overlay">
    <h3 style="margin: 0 0 10px 0;">Optimized Fluid Dynamics</h3>
    <div id="status"></div>
    <div style="margin-top: 10px; font-size: 11px; color: #aaa;">
      Move your mouse to create swirling fluid effects!<br>
      Hold mouse button for stronger effects.
    </div>
  </div>
  <div class="fps" id="fps">FPS: --</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const fpsDiv = document.getElementById('fps');
    
    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;
    
    function addStatus(message, type = 'info') {
      const div = document.createElement('div');
      div.className = `status ${type}`;
      div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
      statusDiv.appendChild(div);
      
      while (statusDiv.children.length > 6) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
    }
    
    // Set canvas size with optimized resolution
    function resizeCanvas() {
      canvas.width = Math.floor(window.innerWidth * 0.75); // Slightly lower than working version
      canvas.height = Math.floor(window.innerHeight * 0.75);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Optimized fluid simulation - based on working version but faster
    class OptimizedFluidSimulation {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.size = width * height;
        
        // Current state
        this.density = new Float32Array(this.size);
        this.velocityX = new Float32Array(this.size);
        this.velocityY = new Float32Array(this.size);
        
        // Previous state for time stepping
        this.prevDensity = new Float32Array(this.size);
        this.prevVelocityX = new Float32Array(this.size);
        this.prevVelocityY = new Float32Array(this.size);
        
        // Optimized parameters for better performance
        this.viscosity = 0.0002; // Slightly higher for stability
        this.diffusion = 0.0002;
        this.dt = 0.08; // Slightly smaller time step
        
        addStatus(`Optimized fluid: ${width}x${height}`, 'success');
      }
      
      IX(x, y) {
        return Math.max(0, Math.min(this.size - 1, y * this.width + x));
      }
      
      addDensity(x, y, amount) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        this.density[this.IX(x, y)] += amount;
      }
      
      addVelocity(x, y, vx, vy) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        const index = this.IX(x, y);
        this.velocityX[index] += vx;
        this.velocityY[index] += vy;
      }
      
      setBoundary(b, x) {
        // Optimized boundary conditions - fewer operations
        const w = this.width;
        const h = this.height;
        
        // Vertical boundaries
        for (let i = 1; i < h - 1; i++) {
          const leftIdx = this.IX(0, i);
          const rightIdx = this.IX(w - 1, i);
          x[leftIdx] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
          x[rightIdx] = b === 1 ? -x[this.IX(w - 2, i)] : x[this.IX(w - 2, i)];
        }
        
        // Horizontal boundaries
        for (let i = 1; i < w - 1; i++) {
          const topIdx = this.IX(i, 0);
          const bottomIdx = this.IX(i, h - 1);
          x[topIdx] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
          x[bottomIdx] = b === 2 ? -x[this.IX(i, h - 2)] : x[this.IX(i, h - 2)];
        }
        
        // Corners
        x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
        x[this.IX(0, h - 1)] = 0.5 * (x[this.IX(1, h - 1)] + x[this.IX(0, h - 2)]);
        x[this.IX(w - 1, 0)] = 0.5 * (x[this.IX(w - 2, 0)] + x[this.IX(w - 1, 1)]);
        x[this.IX(w - 1, h - 1)] = 0.5 * (x[this.IX(w - 2, h - 1)] + x[this.IX(w - 1, h - 2)]);
      }
      
      linearSolve(b, x, x0, a, c, iterations = 3) { // Reduced iterations for performance
        const cRecip = 1.0 / c;
        const w = this.width;
        const h = this.height;
        
        for (let iter = 0; iter < iterations; iter++) {
          for (let j = 1; j < h - 1; j++) {
            for (let i = 1; i < w - 1; i++) {
              const index = this.IX(i, j);
              x[index] = (x0[index] + a * (
                x[this.IX(i + 1, j)] + x[this.IX(i - 1, j)] +
                x[this.IX(i, j + 1)] + x[this.IX(i, j - 1)]
              )) * cRecip;
            }
          }
          this.setBoundary(b, x);
        }
      }
      
      diffuse(b, x, x0, diff) {
        const a = this.dt * diff * (this.width - 2) * (this.height - 2);
        this.linearSolve(b, x, x0, a, 1 + 6 * a);
      }
      
      project(velocX, velocY, p, div) {
        const w = this.width;
        const h = this.height;
        const scale = 0.5 / Math.max(w, h);
        
        // Calculate divergence
        for (let j = 1; j < h - 1; j++) {
          for (let i = 1; i < w - 1; i++) {
            const idx = this.IX(i, j);
            div[idx] = -scale * (
              velocX[this.IX(i + 1, j)] - velocX[this.IX(i - 1, j)] +
              velocY[this.IX(i, j + 1)] - velocY[this.IX(i, j - 1)]
            );
            p[idx] = 0;
          }
        }
        
        this.setBoundary(0, div);
        this.setBoundary(0, p);
        this.linearSolve(0, p, div, 1, 6, 4); // Reduced iterations
        
        // Subtract gradient
        const gradScale = 0.5 * Math.max(w, h);
        for (let j = 1; j < h - 1; j++) {
          for (let i = 1; i < w - 1; i++) {
            const idx = this.IX(i, j);
            velocX[idx] -= gradScale * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]);
            velocY[idx] -= gradScale * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]);
          }
        }
        
        this.setBoundary(1, velocX);
        this.setBoundary(2, velocY);
      }
      
      advect(b, d, d0, velocX, velocY) {
        const w = this.width;
        const h = this.height;
        const dtx = this.dt * (w - 2);
        const dty = this.dt * (h - 2);
        
        for (let j = 1; j < h - 1; j++) {
          for (let i = 1; i < w - 1; i++) {
            const idx = this.IX(i, j);
            
            let x = i - dtx * velocX[idx];
            let y = j - dty * velocY[idx];
            
            // Clamp coordinates
            x = Math.max(0.5, Math.min(w - 1.5, x));
            y = Math.max(0.5, Math.min(h - 1.5, y));
            
            const i0 = Math.floor(x);
            const i1 = i0 + 1;
            const j0 = Math.floor(y);
            const j1 = j0 + 1;
            
            const s1 = x - i0;
            const s0 = 1 - s1;
            const t1 = y - j0;
            const t0 = 1 - t1;
            
            // Bilinear interpolation
            d[idx] = 
              s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
              s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
          }
        }
        
        this.setBoundary(b, d);
      }
      
      step() {
        // Velocity step
        this.diffuse(1, this.prevVelocityX, this.velocityX, this.viscosity);
        this.diffuse(2, this.prevVelocityY, this.velocityY, this.viscosity);
        
        this.project(this.prevVelocityX, this.prevVelocityY, this.velocityX, this.velocityY);
        
        this.advect(1, this.velocityX, this.prevVelocityX, this.prevVelocityX, this.prevVelocityY);
        this.advect(2, this.velocityY, this.prevVelocityY, this.prevVelocityX, this.prevVelocityY);
        
        this.project(this.velocityX, this.velocityY, this.prevVelocityX, this.prevVelocityY);
        
        // Density step
        this.diffuse(0, this.prevDensity, this.density, this.diffusion);
        this.advect(0, this.density, this.prevDensity, this.velocityX, this.velocityY);
        
        // Optimized density fade
        for (let i = 0; i < this.size; i++) {
          this.density[i] *= 0.996; // Slightly slower fade
          if (this.density[i] < 0.05) {
            this.density[i] = 0;
          }
        }
      }
    }
    
    // Initialize fluid with balanced resolution (between /2 and /4)
    const fluidWidth = Math.floor(canvas.width / 2.5);
    const fluidHeight = Math.floor(canvas.height / 2.5);
    const fluid = new OptimizedFluidSimulation(fluidWidth, fluidHeight);
    
    // Mouse tracking
    let mouse = { x: 0, y: 0, lastX: 0, lastY: 0, down: false };
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.lastX = mouse.x;
      mouse.lastY = mouse.y;
      mouse.x = (e.clientX - rect.left) / rect.width;
      mouse.y = (e.clientY - rect.top) / rect.height;
    });
    
    canvas.addEventListener('mousedown', () => {
      mouse.down = true;
      addStatus('Creating strong fluid currents!', 'info');
    });
    
    canvas.addEventListener('mouseup', () => {
      mouse.down = false;
    });
    
    // Optimized animation loop
    let animationId;
    
    function animate(currentTime) {
      // Calculate FPS
      frameCount++;
      if (currentTime - lastTime >= 1000) {
        fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        fpsDiv.textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastTime = currentTime;
      }
      
      // Add mouse influence
      if (mouse.x > 0 && mouse.y > 0) {
        const fluidX = Math.floor(mouse.x * fluidWidth);
        const fluidY = Math.floor(mouse.y * fluidHeight);
        
        const dx = (mouse.x - mouse.lastX) * fluidWidth;
        const dy = (mouse.y - mouse.lastY) * fluidHeight;
        
        if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1 || mouse.down) {
          const radius = mouse.down ? 3 : 2;
          const densityAmount = mouse.down ? 80 : 40;
          const velocityScale = mouse.down ? 40 : 20;
          
          for (let dy_offset = -radius; dy_offset <= radius; dy_offset++) {
            for (let dx_offset = -radius; dx_offset <= radius; dx_offset++) {
              const distance = Math.sqrt(dx_offset * dx_offset + dy_offset * dy_offset);
              if (distance <= radius) {
                const factor = (1 - distance / radius);
                fluid.addDensity(fluidX + dx_offset, fluidY + dy_offset, densityAmount * factor);
                fluid.addVelocity(fluidX + dx_offset, fluidY + dy_offset, 
                  dx * velocityScale * factor, 
                  dy * velocityScale * factor);
              }
            }
          }
        }
      }
      
      // Update fluid simulation
      fluid.step();
      
      // Clear canvas with optimized fade
      ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Render fluid with optimized approach
      const imageData = ctx.createImageData(fluidWidth, fluidHeight);
      const data = imageData.data;
      
      for (let i = 0; i < fluid.size; i++) {
        const density = Math.min(1, fluid.density[i] / 80);
        
        if (density > 0.03) {
          // Create swirling colors based on velocity
          const vx = fluid.velocityX[i];
          const vy = fluid.velocityY[i];
          const velocity = Math.sqrt(vx * vx + vy * vy);
          
          const hue = (Math.atan2(vy, vx) * 180 / Math.PI + 180 + currentTime * 0.03) % 360;
          const saturation = Math.min(100, velocity * 8 + 60);
          const lightness = Math.min(75, density * 120 + 25);
          
          // Optimized HSL to RGB conversion
          const c = (1 - Math.abs(2 * lightness/100 - 1)) * saturation/100;
          const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
          const m = lightness/100 - c / 2;
          
          let r, g, b;
          const h = hue / 60;
          if (h < 1) { r = c; g = x; b = 0; }
          else if (h < 2) { r = x; g = c; b = 0; }
          else if (h < 3) { r = 0; g = c; b = x; }
          else if (h < 4) { r = 0; g = x; b = c; }
          else if (h < 5) { r = x; g = 0; b = c; }
          else { r = c; g = 0; b = x; }
          
          data[i * 4] = Math.floor((r + m) * 255);
          data[i * 4 + 1] = Math.floor((g + m) * 255);
          data[i * 4 + 2] = Math.floor((b + m) * 255);
          data[i * 4 + 3] = Math.floor(density * 255);
        } else {
          // Ensure transparent pixels are completely transparent
          data[i * 4] = 0;
          data[i * 4 + 1] = 0;
          data[i * 4 + 2] = 0;
          data[i * 4 + 3] = 0;
        }
      }
      
      // Draw to canvas with high quality scaling
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = fluidWidth;
      tempCanvas.height = fluidHeight;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(imageData, 0, 0);
      
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.globalCompositeOperation = 'lighter';
      ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
      
      animationId = requestAnimationFrame(animate);
    }
    
    // Start
    addStatus('✅ Optimized fluid dynamics initialized!', 'success');
    addStatus('This uses proper Navier-Stokes with performance optimizations', 'info');
    animationId = requestAnimationFrame(animate);
  </script>
</body>
</html>