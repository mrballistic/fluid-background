<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inline Fluid Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
    }
    
    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 350px;
      font-size: 14px;
    }
    
    .status {
      margin: 5px 0;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .success { background: rgba(0, 255, 0, 0.2); color: #0f0; }
    .error { background: rgba(255, 0, 0, 0.2); color: #f88; }
    .info { background: rgba(0, 0, 255, 0.2); color: #88f; }
    .warning { background: rgba(255, 255, 0, 0.2); color: #ff8; }
    
    .instructions {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #444;
      font-size: 11px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="root"></div>
    <div class="overlay">
      <h3 style="margin: 0 0 10px 0;">Inline Fluid Test</h3>
      <div id="status"></div>
      <div class="instructions">
        This test includes the fluid simulation code inline to avoid CORS issues.
        Move your mouse to see fluid effects!
      </div>
    </div>
  </div>

  <!-- React from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <script>
    const { useState, useEffect, useRef, useCallback } = React;
    const { createRoot } = ReactDOM;

    // Status logging
    function addStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      const div = document.createElement('div');
      div.className = `status ${type}`;
      div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
      statusDiv.appendChild(div);
      console.log(`[${type.toUpperCase()}] ${message}`);
      
      // Keep only last 8 messages
      while (statusDiv.children.length > 8) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
    }

    // Enhanced fluid simulation with better physics
    function useInlineFluidSimulation() {
      const canvasRef = useRef(null);
      const [isInitialized, setIsInitialized] = useState(false);
      const animationRef = useRef(null);
      const mouseRef = useRef({ x: 0, y: 0, down: false, lastX: 0, lastY: 0 });
      
      // Fluid simulation state with proper arrays for Navier-Stokes
      const fluidStateRef = useRef({
        // Current state
        velocityX: null,
        velocityY: null,
        density: null,
        // Previous state for time stepping
        prevVelocityX: null,
        prevVelocityY: null,
        prevDensity: null,
        // Temporary arrays
        temp: null,
        width: 0,
        height: 0,
        // Physics parameters
        viscosity: 0.0001,
        diffusion: 0.0001,
        dt: 0.1
      });

      const initializeFluidSimulation = useCallback(async () => {
        const canvas = canvasRef.current;
        if (!canvas) return false;

        try {
          // Set canvas size
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.max(1, Math.floor(rect.width * dpr));
          canvas.height = Math.max(1, Math.floor(rect.height * dpr));
          
          // We'll use 2D canvas for this simplified version
          const ctx = canvas.getContext('2d');
          if (!ctx) throw new Error('2D canvas not supported');
          
          // Set up canvas
          ctx.fillStyle = 'black';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Initialize fluid simulation grid with proper Navier-Stokes arrays
          const width = Math.floor(canvas.width / 3); // Good balance of performance and quality
          const height = Math.floor(canvas.height / 3);
          const size = width * height;
          
          fluidStateRef.current = {
            // Current state
            velocityX: new Float32Array(size),
            velocityY: new Float32Array(size),
            density: new Float32Array(size),
            // Previous state for time stepping
            prevVelocityX: new Float32Array(size),
            prevVelocityY: new Float32Array(size),
            prevDensity: new Float32Array(size),
            // Temporary arrays
            temp: new Float32Array(size),
            width,
            height,
            // Physics parameters
            viscosity: 0.0001,
            diffusion: 0.0001,
            dt: 0.1
          };
          
          addStatus(`Fluid simulation initialized (${width}x${height})`, 'success');
          setIsInitialized(true);
          return true;
          
        } catch (error) {
          addStatus(`Failed to initialize: ${error.message}`, 'error');
          return false;
        }
      }, []);

      // Proper Navier-Stokes fluid simulation methods
      const IX = useCallback((x, y, width, size) => {
        return Math.max(0, Math.min(size - 1, y * width + x));
      }, []);

      const setBoundary = useCallback((b, x, width, height) => {
        // Set boundary conditions
        for (let i = 1; i < height - 1; i++) {
          x[IX(0, i, width, x.length)] = b === 1 ? -x[IX(1, i, width, x.length)] : x[IX(1, i, width, x.length)];
          x[IX(width - 1, i, width, x.length)] = b === 1 ? -x[IX(width - 2, i, width, x.length)] : x[IX(width - 2, i, width, x.length)];
        }
        
        for (let i = 1; i < width - 1; i++) {
          x[IX(i, 0, width, x.length)] = b === 2 ? -x[IX(i, 1, width, x.length)] : x[IX(i, 1, width, x.length)];
          x[IX(i, height - 1, width, x.length)] = b === 2 ? -x[IX(i, height - 2, width, x.length)] : x[IX(i, height - 2, width, x.length)];
        }
        
        // Corners
        x[IX(0, 0, width, x.length)] = 0.5 * (x[IX(1, 0, width, x.length)] + x[IX(0, 1, width, x.length)]);
        x[IX(0, height - 1, width, x.length)] = 0.5 * (x[IX(1, height - 1, width, x.length)] + x[IX(0, height - 2, width, x.length)]);
        x[IX(width - 1, 0, width, x.length)] = 0.5 * (x[IX(width - 2, 0, width, x.length)] + x[IX(width - 1, 1, width, x.length)]);
        x[IX(width - 1, height - 1, width, x.length)] = 0.5 * (x[IX(width - 2, height - 1, width, x.length)] + x[IX(width - 1, height - 2, width, x.length)]);
      }, [IX]);

      const linearSolve = useCallback((b, x, x0, a, c, width, height, iterations = 4) => {
        const cRecip = 1.0 / c;
        for (let iter = 0; iter < iterations; iter++) {
          for (let j = 1; j < height - 1; j++) {
            for (let i = 1; i < width - 1; i++) {
              const index = IX(i, j, width, x.length);
              x[index] = (x0[index] + a * (
                x[IX(i + 1, j, width, x.length)] + x[IX(i - 1, j, width, x.length)] +
                x[IX(i, j + 1, width, x.length)] + x[IX(i, j - 1, width, x.length)]
              )) * cRecip;
            }
          }
          setBoundary(b, x, width, height);
        }
      }, [IX, setBoundary]);

      const diffuse = useCallback((b, x, x0, diff, dt, width, height) => {
        const a = dt * diff * (width - 2) * (height - 2);
        linearSolve(b, x, x0, a, 1 + 6 * a, width, height);
      }, [linearSolve]);

      const project = useCallback((velocX, velocY, p, div, width, height) => {
        // Calculate divergence
        for (let j = 1; j < height - 1; j++) {
          for (let i = 1; i < width - 1; i++) {
            div[IX(i, j, width, div.length)] = -0.5 * (
              velocX[IX(i + 1, j, width, velocX.length)] - velocX[IX(i - 1, j, width, velocX.length)] +
              velocY[IX(i, j + 1, width, velocY.length)] - velocY[IX(i, j - 1, width, velocY.length)]
            ) / Math.max(width, height);
            p[IX(i, j, width, p.length)] = 0;
          }
        }
        
        setBoundary(0, div, width, height);
        setBoundary(0, p, width, height);
        linearSolve(0, p, div, 1, 6, width, height);
        
        // Subtract gradient
        for (let j = 1; j < height - 1; j++) {
          for (let i = 1; i < width - 1; i++) {
            velocX[IX(i, j, width, velocX.length)] -= 0.5 * (p[IX(i + 1, j, width, p.length)] - p[IX(i - 1, j, width, p.length)]) * Math.max(width, height);
            velocY[IX(i, j, width, velocY.length)] -= 0.5 * (p[IX(i, j + 1, width, p.length)] - p[IX(i, j - 1, width, p.length)]) * Math.max(width, height);
          }
        }
        
        setBoundary(1, velocX, width, height);
        setBoundary(2, velocY, width, height);
      }, [IX, setBoundary, linearSolve]);

      const advect = useCallback((b, d, d0, velocX, velocY, dt, width, height) => {
        const dtx = dt * (width - 2);
        const dty = dt * (height - 2);
        
        for (let j = 1; j < height - 1; j++) {
          for (let i = 1; i < width - 1; i++) {
            let tmp1 = dtx * velocX[IX(i, j, width, velocX.length)];
            let tmp2 = dty * velocY[IX(i, j, width, velocY.length)];
            let x = i - tmp1;
            let y = j - tmp2;
            
            if (x < 0.5) x = 0.5;
            if (x > width - 1.5) x = width - 1.5;
            let i0 = Math.floor(x);
            let i1 = i0 + 1;
            
            if (y < 0.5) y = 0.5;
            if (y > height - 1.5) y = height - 1.5;
            let j0 = Math.floor(y);
            let j1 = j0 + 1;
            
            let s1 = x - i0;
            let s0 = 1 - s1;
            let t1 = y - j0;
            let t0 = 1 - t1;
            
            let i0i = Math.floor(i0);
            let i1i = Math.floor(i1);
            let j0i = Math.floor(j0);
            let j1i = Math.floor(j1);
            
            d[IX(i, j, width, d.length)] = 
              s0 * (t0 * d0[IX(i0i, j0i, width, d0.length)] + t1 * d0[IX(i0i, j1i, width, d0.length)]) +
              s1 * (t0 * d0[IX(i1i, j0i, width, d0.length)] + t1 * d0[IX(i1i, j1i, width, d0.length)]);
          }
        }
        
        setBoundary(b, d, width, height);
      }, [IX, setBoundary]);

      const updateFluidSimulation = useCallback(() => {
        const fluid = fluidStateRef.current;
        const mouse = mouseRef.current;
        
        if (!fluid.velocityX) return;
        
        const { width, height, velocityX, velocityY, density, prevVelocityX, prevVelocityY, prevDensity, temp, viscosity, diffusion, dt } = fluid;
        
        // Add mouse influence
        if (mouse.down || Math.abs(mouse.x - mouse.lastX) > 0.01 || Math.abs(mouse.y - mouse.lastY) > 0.01) {
          const mouseX = Math.floor(mouse.x * width);
          const mouseY = Math.floor(mouse.y * height);
          const radius = mouse.down ? 4 : 2;
          const densityAmount = mouse.down ? 100 : 50;
          const velocityScale = mouse.down ? 50 : 25;
          
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const x = mouseX + dx;
              const y = mouseY + dy;
              
              if (x >= 0 && x < width && y >= 0 && y < height) {
                const index = IX(x, y, width, density.length);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= radius) {
                  const factor = (1 - distance / radius);
                  
                  // Add density
                  density[index] = Math.min(density[index] + densityAmount * factor, 255);
                  
                  // Add velocity
                  const velX = (mouse.x - mouse.lastX) * velocityScale * factor;
                  const velY = (mouse.y - mouse.lastY) * velocityScale * factor;
                  velocityX[index] += velX;
                  velocityY[index] += velY;
                }
              }
            }
          }
        }
        
        // Velocity step (Navier-Stokes)
        diffuse(1, prevVelocityX, velocityX, viscosity, dt, width, height);
        diffuse(2, prevVelocityY, velocityY, viscosity, dt, width, height);
        
        project(prevVelocityX, prevVelocityY, velocityX, velocityY, width, height);
        
        advect(1, velocityX, prevVelocityX, prevVelocityX, prevVelocityY, dt, width, height);
        advect(2, velocityY, prevVelocityY, prevVelocityX, prevVelocityY, dt, width, height);
        
        project(velocityX, velocityY, prevVelocityX, prevVelocityY, width, height);
        
        // Density step
        diffuse(0, prevDensity, density, diffusion, dt, width, height);
        advect(0, density, prevDensity, velocityX, velocityY, dt, width, height);
        
        // Fade density to prevent accumulation
        for (let i = 0; i < density.length; i++) {
          density[i] *= 0.995;
          if (density[i] < 0.1) {
            density[i] = 0;
          }
        }
        
        mouse.lastX = mouse.x;
        mouse.lastY = mouse.y;
      }, [IX, setBoundary, linearSolve, diffuse, project, advect]);

      const renderFluidSimulation = useCallback(() => {
        const canvas = canvasRef.current;
        const fluid = fluidStateRef.current;
        
        if (!canvas || !fluid.density) return;
        
        // Get 2D context
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        // Clear canvas with slight fade for trails
        ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Create image data from density field
        const imageData = new ImageData(fluid.width, fluid.height);
        const data = imageData.data;
        
        for (let i = 0; i < fluid.density.length; i++) {
          const density = Math.min(1, fluid.density[i] / 100);
          
          if (density > 0.05) {
            // Create swirling colors based on velocity
            const vx = fluid.velocityX[i];
            const vy = fluid.velocityY[i];
            const velocity = Math.sqrt(vx * vx + vy * vy);
            
            const hue = (Math.atan2(vy, vx) * 180 / Math.PI + 180 + Date.now() * 0.05) % 360;
            const saturation = Math.min(100, velocity * 10 + 50);
            const lightness = Math.min(80, density * 100 + 20);
            
            // Convert HSL to RGB
            const c = (1 - Math.abs(2 * lightness/100 - 1)) * saturation/100;
            const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
            const m = lightness/100 - c / 2;
            
            let r, g, b;
            if (hue < 60) { r = c; g = x; b = 0; }
            else if (hue < 120) { r = x; g = c; b = 0; }
            else if (hue < 180) { r = 0; g = c; b = x; }
            else if (hue < 240) { r = 0; g = x; b = c; }
            else if (hue < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            data[i * 4] = Math.floor((r + m) * 255);
            data[i * 4 + 1] = Math.floor((g + m) * 255);
            data[i * 4 + 2] = Math.floor((b + m) * 255);
            data[i * 4 + 3] = Math.floor(density * 255);
          } else {
            // Ensure transparent pixels are completely transparent
            data[i * 4] = 0;
            data[i * 4 + 1] = 0;
            data[i * 4 + 2] = 0;
            data[i * 4 + 3] = 0;
          }
        }
        
        // Create temporary canvas for the fluid
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = fluid.width;
        tempCanvas.height = fluid.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageData, 0, 0);
        
        // Scale and draw to main canvas with better blending
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.globalCompositeOperation = 'lighter'; // Better blending for fluid effects
        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        
      }, []);

      const animate = useCallback(() => {
        if (!isInitialized) return;
        
        updateFluidSimulation();
        renderFluidSimulation();
        animationRef.current = requestAnimationFrame(animate);
      }, [updateFluidSimulation, renderFluidSimulation, isInitialized]);

      // Mouse handling
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const handleMouseMove = (e) => {
          const rect = canvas.getBoundingClientRect();
          mouseRef.current.x = (e.clientX - rect.left) / rect.width;
          mouseRef.current.y = (e.clientY - rect.top) / rect.height;
        };

        const handleMouseDown = () => {
          mouseRef.current.down = true;
        };

        const handleMouseUp = () => {
          mouseRef.current.down = false;
        };

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        return () => {
          canvas.removeEventListener('mousemove', handleMouseMove);
          canvas.removeEventListener('mousedown', handleMouseDown);
          canvas.removeEventListener('mouseup', handleMouseUp);
          canvas.removeEventListener('mouseleave', handleMouseUp);
        };
      }, []);

      useEffect(() => {
        initializeFluidSimulation().then(success => {
          if (success) {
            animate();
          }
        });

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [initializeFluidSimulation, animate]);

      return { canvasRef, isInitialized };
    }

    // Test component
    function InlineFluidTest() {
      const { canvasRef, isInitialized } = useInlineFluidSimulation();

      useEffect(() => {
        if (isInitialized) {
          addStatus('✅ Inline fluid simulation running!', 'success');
          addStatus('Move your mouse to create fluid effects', 'info');
        }
      }, [isInitialized]);

      return React.createElement('canvas', {
        ref: canvasRef,
        style: {
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          cursor: 'crosshair'
        }
      });
    }

    // Render
    const root = createRoot(document.getElementById('root'));
    root.render(React.createElement(InlineFluidTest));

    addStatus('Inline fluid test started', 'info');
  </script>
</body>
</html>