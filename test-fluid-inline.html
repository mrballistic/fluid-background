<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inline Fluid Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
    }
    
    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 350px;
      font-size: 14px;
    }
    
    .status {
      margin: 5px 0;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .success { background: rgba(0, 255, 0, 0.2); color: #0f0; }
    .error { background: rgba(255, 0, 0, 0.2); color: #f88; }
    .info { background: rgba(0, 0, 255, 0.2); color: #88f; }
    .warning { background: rgba(255, 255, 0, 0.2); color: #ff8; }
    
    .instructions {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #444;
      font-size: 11px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="root"></div>
    <div class="overlay">
      <h3 style="margin: 0 0 10px 0;">Inline Fluid Test</h3>
      <div id="status"></div>
      <div class="instructions">
        This test includes the fluid simulation code inline to avoid CORS issues.
        Move your mouse to see fluid effects!
      </div>
    </div>
  </div>

  <!-- React from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <script>
    const { useState, useEffect, useRef, useCallback } = React;
    const { createRoot } = ReactDOM;

    // Status logging
    function addStatus(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      const div = document.createElement('div');
      div.className = `status ${type}`;
      div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
      statusDiv.appendChild(div);
      console.log(`[${type.toUpperCase()}] ${message}`);
      
      // Keep only last 8 messages
      while (statusDiv.children.length > 8) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
    }

    // Simplified fluid simulation that shows actual fluid-like effects
    function useInlineFluidSimulation() {
      const canvasRef = useRef(null);
      const [isInitialized, setIsInitialized] = useState(false);
      const glRef = useRef(null);
      const animationRef = useRef(null);
      const mouseRef = useRef({ x: 0, y: 0, down: false, lastX: 0, lastY: 0 });
      
      // Fluid simulation state
      const fluidStateRef = useRef({
        velocityField: null,
        densityField: null,
        width: 0,
        height: 0
      });

      const initializeFluidSimulation = useCallback(async () => {
        const canvas = canvasRef.current;
        if (!canvas) return false;

        try {
          // Set canvas size
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.max(1, Math.floor(rect.width * dpr));
          canvas.height = Math.max(1, Math.floor(rect.height * dpr));
          
          // We'll use 2D canvas for this simplified version
          const ctx = canvas.getContext('2d');
          if (!ctx) throw new Error('2D canvas not supported');
          
          // Set up canvas
          ctx.fillStyle = 'black';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Initialize fluid simulation grid (simplified)
          const width = Math.floor(canvas.width / 4); // Lower resolution for performance
          const height = Math.floor(canvas.height / 4);
          
          fluidStateRef.current = {
            velocityField: new Float32Array(width * height * 2), // x, y velocity
            densityField: new Float32Array(width * height),
            width,
            height
          };
          
          addStatus(`Fluid simulation initialized (${width}x${height})`, 'success');
          setIsInitialized(true);
          return true;
          
        } catch (error) {
          addStatus(`Failed to initialize: ${error.message}`, 'error');
          return false;
        }
      }, []);

      const updateFluidSimulation = useCallback(() => {
        const fluid = fluidStateRef.current;
        const mouse = mouseRef.current;
        
        if (!fluid.velocityField) return;
        
        const { width, height, velocityField, densityField } = fluid;
        
        // Add mouse influence
        if (mouse.down || Math.abs(mouse.x - mouse.lastX) > 0.01 || Math.abs(mouse.y - mouse.lastY) > 0.01) {
          const mouseX = Math.floor(mouse.x * width);
          const mouseY = Math.floor(mouse.y * height);
          const radius = 5;
          
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const x = mouseX + dx;
              const y = mouseY + dy;
              
              if (x >= 0 && x < width && y >= 0 && y < height) {
                const index = y * width + x;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= radius) {
                  const strength = (1 - distance / radius) * 0.5;
                  
                  // Add velocity
                  const velIndex = index * 2;
                  velocityField[velIndex] += (mouse.x - mouse.lastX) * strength * 50;
                  velocityField[velIndex + 1] += (mouse.y - mouse.lastY) * strength * 50;
                  
                  // Add density
                  densityField[index] = Math.min(1, densityField[index] + strength * 0.8);
                }
              }
            }
          }
        }
        
        // Simple fluid dynamics (very simplified)
        const newVelocityField = new Float32Array(velocityField);
        const newDensityField = new Float32Array(densityField);
        
        // Diffusion and advection (simplified)
        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            const index = y * width + x;
            const velIndex = index * 2;
            
            // Velocity diffusion
            const neighbors = [
              ((y-1) * width + x) * 2,
              ((y+1) * width + x) * 2,
              (y * width + (x-1)) * 2,
              (y * width + (x+1)) * 2
            ];
            
            let avgVelX = velocityField[velIndex];
            let avgVelY = velocityField[velIndex + 1];
            
            neighbors.forEach(nIndex => {
              avgVelX += velocityField[nIndex] * 0.1;
              avgVelY += velocityField[nIndex + 1] * 0.1;
            });
            
            newVelocityField[velIndex] = avgVelX * 0.99; // Damping
            newVelocityField[velIndex + 1] = avgVelY * 0.99;
            
            // Density advection
            const velX = velocityField[velIndex] * 0.1;
            const velY = velocityField[velIndex + 1] * 0.1;
            
            const sourceX = Math.max(0, Math.min(width - 1, x - velX));
            const sourceY = Math.max(0, Math.min(height - 1, y - velY));
            
            const x0 = Math.floor(sourceX);
            const y0 = Math.floor(sourceY);
            const x1 = Math.min(width - 1, x0 + 1);
            const y1 = Math.min(height - 1, y0 + 1);
            
            const fx = sourceX - x0;
            const fy = sourceY - y0;
            
            const density00 = densityField[y0 * width + x0];
            const density10 = densityField[y0 * width + x1];
            const density01 = densityField[y1 * width + x0];
            const density11 = densityField[y1 * width + x1];
            
            const interpolated = 
              density00 * (1 - fx) * (1 - fy) +
              density10 * fx * (1 - fy) +
              density01 * (1 - fx) * fy +
              density11 * fx * fy;
            
            newDensityField[index] = interpolated * 0.995; // Fade out
          }
        }
        
        // Update fields
        fluid.velocityField.set(newVelocityField);
        fluid.densityField.set(newDensityField);
        
        mouse.lastX = mouse.x;
        mouse.lastY = mouse.y;
      }, []);

      const renderFluidSimulation = useCallback(() => {
        const canvas = canvasRef.current;
        const fluid = fluidStateRef.current;
        
        if (!canvas || !fluid.densityField) return;
        
        // Get 2D context (don't mix with WebGL)
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        
        // Clear canvas
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Slight fade for trails
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Create image data from density field
        const imageData = new ImageData(fluid.width, fluid.height);
        const data = imageData.data;
        
        for (let i = 0; i < fluid.densityField.length; i++) {
          const density = fluid.densityField[i];
          
          if (density > 0.01) {
            // Create colorful fluid visualization
            const hue = (density * 360 + Date.now() * 0.1) % 360;
            const saturation = Math.min(1, density * 2);
            const lightness = Math.min(0.8, density * 1.5);
            
            // Convert HSL to RGB
            const c = (1 - Math.abs(2 * lightness - 1)) * saturation;
            const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
            const m = lightness - c / 2;
            
            let r, g, b;
            if (hue < 60) { r = c; g = x; b = 0; }
            else if (hue < 120) { r = x; g = c; b = 0; }
            else if (hue < 180) { r = 0; g = c; b = x; }
            else if (hue < 240) { r = 0; g = x; b = c; }
            else if (hue < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            data[i * 4] = Math.floor((r + m) * 255);
            data[i * 4 + 1] = Math.floor((g + m) * 255);
            data[i * 4 + 2] = Math.floor((b + m) * 255);
            data[i * 4 + 3] = Math.floor(density * 255);
          } else {
            // Transparent for low density
            data[i * 4] = 0;
            data[i * 4 + 1] = 0;
            data[i * 4 + 2] = 0;
            data[i * 4 + 3] = 0;
          }
        }
        
        // Create temporary canvas for the fluid
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = fluid.width;
        tempCanvas.height = fluid.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageData, 0, 0);
        
        // Scale and draw to main canvas with blending
        ctx.globalCompositeOperation = 'screen';
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        
      }, []);

      const animate = useCallback(() => {
        if (!isInitialized) return;
        
        updateFluidSimulation();
        renderFluidSimulation();
        animationRef.current = requestAnimationFrame(animate);
      }, [updateFluidSimulation, renderFluidSimulation, isInitialized]);

      // Mouse handling
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const handleMouseMove = (e) => {
          const rect = canvas.getBoundingClientRect();
          mouseRef.current.x = (e.clientX - rect.left) / rect.width;
          mouseRef.current.y = (e.clientY - rect.top) / rect.height;
        };

        const handleMouseDown = () => {
          mouseRef.current.down = true;
        };

        const handleMouseUp = () => {
          mouseRef.current.down = false;
        };

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        return () => {
          canvas.removeEventListener('mousemove', handleMouseMove);
          canvas.removeEventListener('mousedown', handleMouseDown);
          canvas.removeEventListener('mouseup', handleMouseUp);
          canvas.removeEventListener('mouseleave', handleMouseUp);
        };
      }, []);

      useEffect(() => {
        initializeFluidSimulation().then(success => {
          if (success) {
            animate();
          }
        });

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [initializeFluidSimulation, animate]);

      return { canvasRef, isInitialized };
    }

    // Test component
    function InlineFluidTest() {
      const { canvasRef, isInitialized } = useInlineFluidSimulation();

      useEffect(() => {
        if (isInitialized) {
          addStatus('âœ… Inline fluid simulation running!', 'success');
          addStatus('Move your mouse to create fluid effects', 'info');
        }
      }, [isInitialized]);

      return React.createElement('canvas', {
        ref: canvasRef,
        style: {
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          cursor: 'crosshair'
        }
      });
    }

    // Render
    const root = createRoot(document.getElementById('root'));
    root.render(React.createElement(InlineFluidTest));

    addStatus('Inline fluid test started', 'info');
  </script>
</body>
</html>