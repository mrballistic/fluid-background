<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Optimized Fluid Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
    }
    
    canvas {
      display: block;
      cursor: crosshair;
    }
    
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      max-width: 350px;
      font-size: 14px;
    }
    
    .status {
      margin: 5px 0;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .success { background: rgba(0, 255, 0, 0.2); color: #0f0; }
    .error { background: rgba(255, 0, 0, 0.2); color: #f88; }
    .info { background: rgba(0, 0, 255, 0.2); color: #88f; }
    .warning { background: rgba(255, 255, 0, 0.2); color: #ff8; }
    
    .fps {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="overlay">
    <h3 style="margin: 0 0 10px 0;">Optimized Fluid Simulation</h3>
    <div id="status"></div>
    <div style="margin-top: 10px; font-size: 11px; color: #aaa;">
      Move your mouse to create fluid effects. Watch the FPS counter!
    </div>
  </div>
  <div class="fps" id="fps">FPS: --</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const fpsDiv = document.getElementById('fps');
    
    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;
    
    function addStatus(message, type = 'info') {
      const div = document.createElement('div');
      div.className = `status ${type}`;
      div.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
      statusDiv.appendChild(div);
      console.log(`[${type.toUpperCase()}] ${message}`);
      
      // Keep only last 6 messages
      while (statusDiv.children.length > 6) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
    }
    
    // Set canvas size with lower resolution for performance
    function resizeCanvas() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap pixel ratio
      canvas.width = Math.floor(window.innerWidth * 0.5); // Half resolution
      canvas.height = Math.floor(window.innerHeight * 0.5);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      
      addStatus(`Canvas: ${canvas.width}x${canvas.height} (display: ${window.innerWidth}x${window.innerHeight})`, 'info');
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Simplified fluid simulation
    class FluidSimulation {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.size = width * height;
        
        // Use smaller arrays for better performance
        this.density = new Float32Array(this.size);
        this.velocityX = new Float32Array(this.size);
        this.velocityY = new Float32Array(this.size);
        
        // Temporary arrays for calculations
        this.tempDensity = new Float32Array(this.size);
        this.tempVelX = new Float32Array(this.size);
        this.tempVelY = new Float32Array(this.size);
        
        addStatus(`Fluid grid: ${width}x${height} (${this.size} cells)`, 'success');
      }
      
      addDensity(x, y, amount) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        const index = y * this.width + x;
        this.density[index] = Math.min(1, this.density[index] + amount);
      }
      
      addVelocity(x, y, vx, vy) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        const index = y * this.width + x;
        this.velocityX[index] += vx;
        this.velocityY[index] += vy;
      }
      
      step() {
        try {
          // Simple diffusion
          this.diffuse();
          
          // Simple advection
          this.advect();
          
          // Fade density over time
          for (let i = 0; i < this.size; i++) {
            this.density[i] *= 0.99;
            this.velocityX[i] *= 0.95;
            this.velocityY[i] *= 0.95;
          }
        } catch (error) {
          addStatus(`Simulation error: ${error.message}`, 'error');
          console.error('Fluid simulation error:', error);
        }
      }
      
      diffuse() {
        // Very simple diffusion - just average with neighbors
        for (let y = 1; y < this.height - 1; y++) {
          for (let x = 1; x < this.width - 1; x++) {
            const index = y * this.width + x;
            
            const neighbors = [
              this.density[(y-1) * this.width + x],
              this.density[(y+1) * this.width + x],
              this.density[y * this.width + (x-1)],
              this.density[y * this.width + (x+1)]
            ];
            
            const avg = neighbors.reduce((sum, val) => sum + val, 0) / 4;
            this.tempDensity[index] = (this.density[index] + avg * 0.1) / 1.1;
          }
        }
        
        // Copy back
        for (let i = 0; i < this.size; i++) {
          this.density[i] = this.tempDensity[i] || this.density[i];
        }
      }
      
      advect() {
        // Very simple advection
        for (let y = 1; y < this.height - 1; y++) {
          for (let x = 1; x < this.width - 1; x++) {
            const index = y * this.width + x;
            
            const vx = this.velocityX[index] * 0.1;
            const vy = this.velocityY[index] * 0.1;
            
            const sourceX = Math.max(0, Math.min(this.width - 1, x - vx));
            const sourceY = Math.max(0, Math.min(this.height - 1, y - vy));
            
            const x0 = Math.floor(sourceX);
            const y0 = Math.floor(sourceY);
            const x1 = Math.min(this.width - 1, x0 + 1);
            const y1 = Math.min(this.height - 1, y0 + 1);
            
            const fx = sourceX - x0;
            const fy = sourceY - y0;
            
            const density00 = this.density[y0 * this.width + x0] || 0;
            const density10 = this.density[y0 * this.width + x1] || 0;
            const density01 = this.density[y1 * this.width + x0] || 0;
            const density11 = this.density[y1 * this.width + x1] || 0;
            
            this.tempDensity[index] = 
              density00 * (1 - fx) * (1 - fy) +
              density10 * fx * (1 - fy) +
              density01 * (1 - fx) * fy +
              density11 * fx * fy;
          }
        }
        
        // Copy back
        for (let i = 0; i < this.size; i++) {
          this.density[i] = this.tempDensity[i] || this.density[i];
        }
      }
    }
    
    // Initialize fluid simulation
    const fluidWidth = Math.floor(canvas.width / 4);
    const fluidHeight = Math.floor(canvas.height / 4);
    const fluid = new FluidSimulation(fluidWidth, fluidHeight);
    
    // Mouse tracking
    let mouse = { x: 0, y: 0, lastX: 0, lastY: 0, down: false };
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.lastX = mouse.x;
      mouse.lastY = mouse.y;
      mouse.x = (e.clientX - rect.left) / rect.width;
      mouse.y = (e.clientY - rect.top) / rect.height;
    });
    
    canvas.addEventListener('mousedown', () => {
      mouse.down = true;
      addStatus('Mouse down - adding more fluid!', 'info');
    });
    
    canvas.addEventListener('mouseup', () => {
      mouse.down = false;
    });
    
    // Animation loop with error handling
    let animationId;
    let isRunning = true;
    
    function animate(currentTime) {
      if (!isRunning) return;
      
      try {
        // Calculate FPS
        frameCount++;
        if (currentTime - lastTime >= 1000) {
          fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
          fpsDiv.textContent = `FPS: ${fps}`;
          frameCount = 0;
          lastTime = currentTime;
          
          // Check for performance issues
          if (fps < 10) {
            addStatus(`Low FPS detected: ${fps}`, 'warning');
          }
        }
        
        // Add mouse influence to fluid
        if (mouse.x > 0 && mouse.y > 0) {
          const fluidX = Math.floor(mouse.x * fluidWidth);
          const fluidY = Math.floor(mouse.y * fluidHeight);
          
          const dx = mouse.x - mouse.lastX;
          const dy = mouse.y - mouse.lastY;
          
          if (Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001 || mouse.down) {
            const radius = mouse.down ? 3 : 2;
            const strength = mouse.down ? 0.8 : 0.4;
            
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= radius) {
                  const factor = (1 - distance / radius) * strength;
                  fluid.addDensity(fluidX + dx, fluidY + dy, factor);
                  fluid.addVelocity(fluidX + dx, fluidY + dy, 
                    (mouse.x - mouse.lastX) * 20, 
                    (mouse.y - mouse.lastY) * 20);
                }
              }
            }
          }
        }
        
        // Update fluid simulation
        fluid.step();
        
        // Render
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw fluid
        const imageData = ctx.createImageData(fluidWidth, fluidHeight);
        const data = imageData.data;
        
        for (let i = 0; i < fluid.size; i++) {
          const density = fluid.density[i];
          if (density > 0.01) {
            const hue = (density * 360 + currentTime * 0.1) % 360;
            const saturation = Math.min(100, density * 200);
            const lightness = Math.min(80, density * 150);
            
            // Simple HSL to RGB conversion
            const c = (1 - Math.abs(2 * lightness/100 - 1)) * saturation/100;
            const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
            const m = lightness/100 - c / 2;
            
            let r, g, b;
            if (hue < 60) { r = c; g = x; b = 0; }
            else if (hue < 120) { r = x; g = c; b = 0; }
            else if (hue < 180) { r = 0; g = c; b = x; }
            else if (hue < 240) { r = 0; g = x; b = c; }
            else if (hue < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            data[i * 4] = Math.floor((r + m) * 255);
            data[i * 4 + 1] = Math.floor((g + m) * 255);
            data[i * 4 + 2] = Math.floor((b + m) * 255);
            data[i * 4 + 3] = Math.floor(density * 255);
          }
        }
        
        // Create temporary canvas and scale up
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = fluidWidth;
        tempCanvas.height = fluidHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageData, 0, 0);
        
        // Draw scaled up with smooth interpolation
        ctx.imageSmoothingEnabled = true;
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        
        // Continue animation
        animationId = requestAnimationFrame(animate);
        
      } catch (error) {
        addStatus(`Animation error: ${error.message}`, 'error');
        console.error('Animation loop error:', error);
        isRunning = false;
      }
    }
    
    // Start animation
    addStatus('âœ… Starting optimized fluid simulation', 'success');
    animationId = requestAnimationFrame(animate);
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      isRunning = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    });
    
    // Add performance monitoring
    setTimeout(() => {
      if (fps < 30) {
        addStatus('Performance may be limited - try a smaller window', 'warning');
      } else {
        addStatus(`Good performance: ${fps} FPS`, 'success');
      }
    }, 3000);
  </script>
</body>
</html>