<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Fluid Dynamics</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
    }
    
    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
      font-size: 14px;
      border: 1px solid #333;
    }
    
    .status {
      margin: 8px 0;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 13px;
      border-left: 4px solid;
    }
    
    .success { 
      background: rgba(0, 255, 0, 0.1); 
      color: #0f0; 
      border-left-color: #0f0;
    }
    .error { 
      background: rgba(255, 0, 0, 0.1); 
      color: #f88; 
      border-left-color: #f00;
    }
    .info { 
      background: rgba(0, 0, 255, 0.1); 
      color: #88f; 
      border-left-color: #00f;
    }
    .warning { 
      background: rgba(255, 255, 0, 0.1); 
      color: #ff8; 
      border-left-color: #ff0;
    }
    
    .fps {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      padding: 15px;
      border-radius: 8px;
      font-family: monospace;
      border: 1px solid #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="canvas"></canvas>
    
    <div class="overlay">
      <h3 style="margin: 0 0 15px 0; color: #0ff;">🌊 WebGL Fluid Dynamics</h3>
      <div id="status"></div>
      
      <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444; font-size: 12px; color: #aaa; line-height: 1.4;">
        <strong>Instructions:</strong><br>
        • Move your mouse to create fluid effects<br>
        • Hold mouse button for stronger currents<br>
        • This uses real Navier-Stokes physics with WebGL rendering
      </div>
    </div>
    
    <div class="fps" id="fps">
      FPS: --<br>
      Frame: --
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const statusDiv = document.getElementById('status');
    const fpsDiv = document.getElementById('fps');
    
    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();
    let totalFrames = 0;
    
    function addStatus(message, type = 'info') {
      const div = document.createElement('div');
      div.className = `status ${type}`;
      
      const timestamp = new Date().toLocaleTimeString();
      div.innerHTML = `<strong>${timestamp}:</strong> ${message}`;
      
      statusDiv.appendChild(div);
      console.log(`[${type.toUpperCase()}] ${timestamp}: ${message}`);
      
      // Keep only last 8 messages
      while (statusDiv.children.length > 8) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
    }
    
    function updateFPS() {
      const now = performance.now();
      frameCount++;
      totalFrames++;
      
      if (now - lastTime >= 1000) {
        const fps = Math.round((frameCount * 1000) / (now - lastTime));
        fpsDiv.innerHTML = `FPS: ${fps}<br>Frame: ${totalFrames}`;
        frameCount = 0;
        lastTime = now;
      }
    }
    
    // WebGL Fluid Dynamics - CPU physics, GPU rendering
    class WebGLFluidDynamics {
      constructor(canvas) {
        this.canvas = canvas;
        this.gl = null;
        this.program = null;
        this.texture = null;
        this.mouse = { x: 0, y: 0, lastX: 0, lastY: 0, down: false };
        this.initialized = false;
        
        // Fluid simulation state (same as working 2D version)
        this.fluidState = {
          velocityX: null,
          velocityY: null,
          density: null,
          prevVelocityX: null,
          prevVelocityY: null,
          prevDensity: null,
          temp: null,
          width: 0,
          height: 0,
          viscosity: 0.0001,
          diffusion: 0.0001,
          dt: 0.1
        };
      }
      
      async initialize() {
        try {
          // Get WebGL context
          this.gl = this.canvas.getContext('webgl', {
            alpha: false,
            depth: false,
            stencil: false,
            antialias: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false
          });
          
          if (!this.gl) {
            throw new Error('WebGL not supported');
          }
          
          addStatus(`WebGL context created: ${this.gl.getParameter(this.gl.VERSION)}`, 'success');
          
          // Set canvas size
          this.resize();
          
          // Initialize fluid simulation
          this.initializeFluidSimulation();
          
          // Initialize WebGL rendering
          await this.initializeWebGLRendering();
          
          // Set up mouse events
          this.setupMouseEvents();
          
          this.initialized = true;
          addStatus('WebGL fluid dynamics initialized!', 'success');
          
          return true;
        } catch (error) {
          addStatus(`Initialization failed: ${error.message}`, 'error');
          return false;
        }
      }
      
      resize() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = Math.floor(rect.width * dpr);
        this.canvas.height = Math.floor(rect.height * dpr);
        
        if (this.gl) {
          this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        }
      }
      
      initializeFluidSimulation() {
        // Initialize fluid simulation grid - much smaller for performance
        const width = Math.floor(this.canvas.width / 8); // Much smaller grid
        const height = Math.floor(this.canvas.height / 8);
        const size = width * height;
        
        this.fluidState = {
          // Current state
          velocityX: new Float32Array(size),
          velocityY: new Float32Array(size),
          density: new Float32Array(size),
          // Previous state for time stepping
          prevVelocityX: new Float32Array(size),
          prevVelocityY: new Float32Array(size),
          prevDensity: new Float32Array(size),
          // Temporary arrays
          temp: new Float32Array(size),
          width,
          height,
          // Physics parameters
          viscosity: 0.0001,
          diffusion: 0.0001,
          dt: 0.1
        };
        
        addStatus(`Fluid simulation: ${width}x${height}`, 'success');
      }
      
      async initializeWebGLRendering() {
        const gl = this.gl;
        
        // Simple vertex shader for texture rendering
        const vertexShaderSource = `
          attribute vec2 a_position;
          attribute vec2 a_texCoord;
          
          varying vec2 v_texCoord;
          
          void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_texCoord;
          }
        `;
        
        // Fragment shader for fluid visualization - simplified
        const fragmentShaderSource = `
          precision mediump float;
          
          uniform sampler2D u_texture;
          uniform float u_time;
          
          varying vec2 v_texCoord;
          
          void main() {
            vec4 texel = texture2D(u_texture, v_texCoord);
            float density = texel.r / 255.0;
            float velocityX = (texel.g / 255.0 - 0.5) * 2.0;
            float velocityY = (texel.b / 255.0 - 0.5) * 2.0;
            
            if (density > 0.02) {
              // Create swirling colors based on velocity
              float velocity = sqrt(velocityX * velocityX + velocityY * velocityY);
              float hue = atan(velocityY, velocityX) + u_time * 0.5;
              
              // Simple RGB color generation
              float r = sin(hue) * 0.5 + 0.5;
              float g = sin(hue + 2.094) * 0.5 + 0.5; // 2π/3
              float b = sin(hue + 4.188) * 0.5 + 0.5; // 4π/3
              
              // Enhance colors based on velocity and density
              r = r * (0.5 + velocity * 2.0) * density * 2.0;
              g = g * (0.5 + velocity * 2.0) * density * 2.0;
              b = b * (0.5 + velocity * 2.0) * density * 2.0;
              
              gl_FragColor = vec4(r, g, b, density);
            } else {
              gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
          }
        `;
        
        // Create shaders
        const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        // Create program
        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          throw new Error('Program link error: ' + gl.getProgramInfoLog(this.program));
        }
        
        // Create quad for rendering
        const vertices = new Float32Array([
          // Position  // TexCoord
          -1, -1,      0, 0,
          -1,  1,      0, 1,
           1,  1,      1, 1,
           1, -1,      1, 0
        ]);
        
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        // Create texture for fluid data
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        addStatus('WebGL rendering initialized', 'success');
      }
      
      createShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          throw new Error('Shader compile error: ' + gl.getShaderInfoLog(shader));
        }
        
        return shader;
      }
      
      setupMouseEvents() {
        const updateMouse = (e) => {
          const rect = this.canvas.getBoundingClientRect();
          this.mouse.lastX = this.mouse.x;
          this.mouse.lastY = this.mouse.y;
          this.mouse.x = (e.clientX - rect.left) / rect.width;
          this.mouse.y = (e.clientY - rect.top) / rect.height;
        };
        
        this.canvas.addEventListener('mousemove', updateMouse);
        this.canvas.addEventListener('mousedown', (e) => {
          this.mouse.down = true;
          updateMouse(e);
        });
        this.canvas.addEventListener('mouseup', () => {
          this.mouse.down = false;
        });
        this.canvas.addEventListener('mouseleave', () => {
          this.mouse.down = false;
        });
      }
      
      // Navier-Stokes fluid simulation methods (same as working 2D version)
      IX(x, y) {
        const fluid = this.fluidState;
        return Math.max(0, Math.min(fluid.width * fluid.height - 1, y * fluid.width + x));
      }
      
      setBoundary(b, x) {
        const fluid = this.fluidState;
        const { width, height } = fluid;
        
        // Set boundary conditions
        for (let i = 1; i < height - 1; i++) {
          x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
          x[this.IX(width - 1, i)] = b === 1 ? -x[this.IX(width - 2, i)] : x[this.IX(width - 2, i)];
        }
        
        for (let i = 1; i < width - 1; i++) {
          x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
          x[this.IX(i, height - 1)] = b === 2 ? -x[this.IX(i, height - 2)] : x[this.IX(i, height - 2)];
        }
        
        // Corners
        x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
        x[this.IX(0, height - 1)] = 0.5 * (x[this.IX(1, height - 1)] + x[this.IX(0, height - 2)]);
        x[this.IX(width - 1, 0)] = 0.5 * (x[this.IX(width - 2, 0)] + x[this.IX(width - 1, 1)]);
        x[this.IX(width - 1, height - 1)] = 0.5 * (x[this.IX(width - 2, height - 1)] + x[this.IX(width - 1, height - 2)]);
      }
      
      linearSolve(b, x, x0, a, c, iterations = 4) {
        const fluid = this.fluidState;
        const { width, height } = fluid;
        const cRecip = 1.0 / c;
        
        for (let iter = 0; iter < iterations; iter++) {
          for (let j = 1; j < height - 1; j++) {
            for (let i = 1; i < width - 1; i++) {
              const index = this.IX(i, j);
              x[index] = (x0[index] + a * (
                x[this.IX(i + 1, j)] + x[this.IX(i - 1, j)] +
                x[this.IX(i, j + 1)] + x[this.IX(i, j - 1)]
              )) * cRecip;
            }
          }
          this.setBoundary(b, x);
        }
      }
      
      diffuse(b, x, x0, diff) {
        const fluid = this.fluidState;
        const { width, height, dt } = fluid;
        const a = dt * diff * (width - 2) * (height - 2);
        this.linearSolve(b, x, x0, a, 1 + 6 * a);
      }
      
      project(velocX, velocY, p, div) {
        const fluid = this.fluidState;
        const { width, height } = fluid;
        
        // Calculate divergence
        for (let j = 1; j < height - 1; j++) {
          for (let i = 1; i < width - 1; i++) {
            div[this.IX(i, j)] = -0.5 * (
              velocX[this.IX(i + 1, j)] - velocX[this.IX(i - 1, j)] +
              velocY[this.IX(i, j + 1)] - velocY[this.IX(i, j - 1)]
            ) / Math.max(width, height);
            p[this.IX(i, j)] = 0;
          }
        }
        
        this.setBoundary(0, div);
        this.setBoundary(0, p);
        this.linearSolve(0, p, div, 1, 6);
        
        // Subtract gradient
        for (let j = 1; j < height - 1; j++) {
          for (let i = 1; i < width - 1; i++) {
            velocX[this.IX(i, j)] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) * Math.max(width, height);
            velocY[this.IX(i, j)] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) * Math.max(width, height);
          }
        }
        
        this.setBoundary(1, velocX);
        this.setBoundary(2, velocY);
      }
      
      advect(b, d, d0, velocX, velocY) {
        const fluid = this.fluidState;
        const { width, height, dt } = fluid;
        const dtx = dt * (width - 2);
        const dty = dt * (height - 2);
        
        for (let j = 1; j < height - 1; j++) {
          for (let i = 1; i < width - 1; i++) {
            let tmp1 = dtx * velocX[this.IX(i, j)];
            let tmp2 = dty * velocY[this.IX(i, j)];
            let x = i - tmp1;
            let y = j - tmp2;
            
            if (x < 0.5) x = 0.5;
            if (x > width - 1.5) x = width - 1.5;
            let i0 = Math.floor(x);
            let i1 = i0 + 1;
            
            if (y < 0.5) y = 0.5;
            if (y > height - 1.5) y = height - 1.5;
            let j0 = Math.floor(y);
            let j1 = j0 + 1;
            
            let s1 = x - i0;
            let s0 = 1 - s1;
            let t1 = y - j0;
            let t0 = 1 - t1;
            
            let i0i = Math.floor(i0);
            let i1i = Math.floor(i1);
            let j0i = Math.floor(j0);
            let j1i = Math.floor(j1);
            
            d[this.IX(i, j)] = 
              s0 * (t0 * d0[this.IX(i0i, j0i)] + t1 * d0[this.IX(i0i, j1i)]) +
              s1 * (t0 * d0[this.IX(i1i, j0i)] + t1 * d0[this.IX(i1i, j1i)]);
          }
        }
        
        this.setBoundary(b, d);
      }
      
      updateFluidSimulation() {
        const fluid = this.fluidState;
        const mouse = this.mouse;
        
        const { width, height, velocityX, velocityY, density, prevVelocityX, prevVelocityY, prevDensity, viscosity, diffusion } = fluid;
        
        // Add mouse influence
        if (mouse.down || Math.abs(mouse.x - mouse.lastX) > 0.01 || Math.abs(mouse.y - mouse.lastY) > 0.01) {
          const mouseX = Math.floor(mouse.x * width);
          const mouseY = Math.floor(mouse.y * height);
          const radius = mouse.down ? 4 : 2;
          const densityAmount = mouse.down ? 100 : 50;
          const velocityScale = mouse.down ? 50 : 25;
          
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const x = mouseX + dx;
              const y = mouseY + dy;
              
              if (x >= 0 && x < width && y >= 0 && y < height) {
                const index = this.IX(x, y);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= radius) {
                  const factor = (1 - distance / radius);
                  
                  // Add density
                  density[index] = Math.min(density[index] + densityAmount * factor, 255);
                  
                  // Add velocity
                  const velX = (mouse.x - mouse.lastX) * velocityScale * factor;
                  const velY = (mouse.y - mouse.lastY) * velocityScale * factor;
                  velocityX[index] += velX;
                  velocityY[index] += velY;
                }
              }
            }
          }
        }
        
        // Velocity step (Navier-Stokes)
        this.diffuse(1, prevVelocityX, velocityX, viscosity);
        this.diffuse(2, prevVelocityY, velocityY, viscosity);
        
        this.project(prevVelocityX, prevVelocityY, velocityX, velocityY);
        
        this.advect(1, velocityX, prevVelocityX, prevVelocityX, prevVelocityY);
        this.advect(2, velocityY, prevVelocityY, prevVelocityX, prevVelocityY);
        
        this.project(velocityX, velocityY, prevVelocityX, prevVelocityY);
        
        // Density step
        this.diffuse(0, prevDensity, density, diffusion);
        this.advect(0, density, prevDensity, velocityX, velocityY);
        
        // Fade density to prevent accumulation
        for (let i = 0; i < density.length; i++) {
          density[i] *= 0.995;
          if (density[i] < 0.1) {
            density[i] = 0;
          }
        }
        
        mouse.lastX = mouse.x;
        mouse.lastY = mouse.y;
      }
      
      render() {
        if (!this.initialized) return;
        
        // Update fluid simulation (CPU)
        this.updateFluidSimulation();
        
        // Render with WebGL (GPU)
        this.renderWithWebGL();
        
        updateFPS();
      }
      
      renderWithWebGL() {
        const gl = this.gl;
        const fluid = this.fluidState;
        
        // Prepare texture data (pack density and velocity into RGBA)
        const textureData = new Uint8Array(fluid.width * fluid.height * 4);
        
        for (let i = 0; i < fluid.density.length; i++) {
          const density = Math.min(255, Math.max(0, fluid.density[i] * 2.55)); // Scale density
          const velocityX = Math.min(255, Math.max(0, (fluid.velocityX[i] * 0.01 + 0.5) * 255));
          const velocityY = Math.min(255, Math.max(0, (fluid.velocityY[i] * 0.01 + 0.5) * 255));
          
          textureData[i * 4] = density;     // R: density
          textureData[i * 4 + 1] = velocityX; // G: velocity X
          textureData[i * 4 + 2] = velocityY; // B: velocity Y
          textureData[i * 4 + 3] = 255;       // A: always opaque
        }
        
        // Upload texture data
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fluid.width, fluid.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, textureData);
        
        // Debug: Check if we have any density
        let maxDensity = 0;
        for (let i = 0; i < fluid.density.length; i++) {
          maxDensity = Math.max(maxDensity, fluid.density[i]);
        }
        
        if (maxDensity > 0 && totalFrames % 60 === 0) { // Log every 60 frames
          addStatus(`Max density: ${maxDensity.toFixed(2)}`, 'info');
        }
        
        // Clear and render
        gl.clearColor(0.02, 0.02, 0.05, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Enable blending
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        // Use shader program
        gl.useProgram(this.program);
        
        // Set uniforms
        const textureLocation = gl.getUniformLocation(this.program, 'u_texture');
        const timeLocation = gl.getUniformLocation(this.program, 'u_time');
        gl.uniform1i(textureLocation, 0);
        gl.uniform1f(timeLocation, Date.now() * 0.001);
        
        // Set attributes
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        
        const positionLocation = gl.getAttribLocation(this.program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(this.program, 'a_texCoord');
        
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
        
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);
        
        // Draw quad
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        
        gl.disable(gl.BLEND);
      }
    }
    
    // Initialize and run the simulation
    async function main() {
      addStatus('🚀 Starting WebGL fluid dynamics...', 'info');
      
      const simulation = new WebGLFluidDynamics(canvas);
      
      if (await simulation.initialize()) {
        addStatus('🎉 WebGL fluid dynamics ready!', 'success');
        addStatus('Move your mouse to create real fluid effects', 'info');
        
        function animate() {
          simulation.render();
          requestAnimationFrame(animate);
        }
        
        animate();
      } else {
        addStatus('❌ Failed to initialize WebGL fluid dynamics', 'error');
      }
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      if (window.simulation) {
        window.simulation.resize();
      }
    });
    
    // Start the simulation
    main().catch(error => {
      addStatus(`Fatal error: ${error.message}`, 'error');
      console.error(error);
    });
  </script>
</body>
</html>